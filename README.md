# 목차
- [서비스 소개](#서비스-소개)
  * 졸라바요
- [프로젝트 구성 안내](#프로젝트-구성-안내)
  * 1. 프로젝트 아키텍처
  * 2. DB diagram
- [고민했던 포인트](#고민했던-포인트)
  * 1. 서비스 로그인과 Oauth2.0 로그인 통합
  * 2. 청첩장을 받은 사용자만 해당 청첩장에 접근하도록 설계
- [향후 계획](#향후-계획)

<br>

# 서비스 소개
### 졸라바요
- 예비 신랑 신부가 결혼식 청첩장을 만들고 공유할 수 있는 서비스입니다.
- 청첩장을 보낼 때 사진과 자신이 받고 싶은 선물 목록을 같이 보낼 수 있습니다.
- 청첩장을 받은 사람은 결혼식 정보, 신랑 신부 사진 및 선물 정보를 통해 원하는 선물에 축의금을 얼마 보낼 지 작성할 수 있습니다.
- 청첩장을 받은 사람은 해당 결혼식 참석 여부를 선택할 수 있습니다.
- 예비 신랑 신부는 청첩장을 받은 사람들의 참석 여부와 선물에 보낼 축의금 정보를 통해 결혼식 준비를 편하게 할 수 있습니다.

<br>


# 프로젝트 구성 안내
  ### 1. 프로젝트 아키텍처

ec2-application 서버에는 실제 Spring Boot Application과 로그 수집에 필요한 promtail 서비스가 컨테이너 형태로 띄워져 있습니다.

ec2-monitoring 서버에는 해당 어플리케이션을 관제할 수 있는 스택들인 prometheus, loki, grafana 서비스가 컨테이너 형태로 띄워져 있습니다.

AWS S3 객체의 경우 어플리케이션을 통해 쓰기, 읽기가 가능하며

Public으로 읽기에 대해서만 오픈했기 때문에 클라이언트에서 해당 이미지를 직접 받아올 수 있도록 설계했습니다.

<br>
<centor><img src="https://github.com/Wedding-Registry/Back/assets/91299082/5ce63bed-fe0e-4866-be9e-7fc4693c67e4.png" width="80%" height="80%">


  ### 2. DB diagram

users 테이블에서 자기 자신을 참조하도록 users_id와 parent_id를 둔 이유는

이후에 만약 신랑 신부가 전부 서비스에 가입을 한 경우 서로가 부부임을 확인하기 위해 설정하였습니다.

boards 테이블에 uuid_first, uuid_second 컬럼은 해당 예비 신랑, 신부의 게시판에 해당하는 청첩장을 전달할 때

단 하나의 값과 초대되지 않은 다른 신랑, 신부의 청첩장에 접근하는 것을 막기 위해 추가했습니다.


<br>
<centor><img src="https://github.com/Wedding-Registry/Back/assets/91299082/adcbf563-5e84-4608-afcf-628975cb8cd9.png" width="100%" height="100%">

<br>


# 고민했던 포인트
  ### 1. 서비스 로그인과 Oauth2.0 로그인 통합

<br>
Spring Security를 사용하여 로그인과 회원가입을 구현하였는데 Security의 Oauth 관련 필터를 이용하여 구현하기가 시간적으로 어렵다고 판단하여

서비스 자체의 로그인 포멧과 동일하게 이메일과 비밀번호를 받도록 설정하였고, 소셜 로그인 시 비밀번호는 제공받는 유일한 사용자 id 값에 kakao, google을 표시하여 넘기도록 했습니다.

이후 필요한 필요한 사용자 정보를 추가로 받는 작업을 마무리 하고 로그인 및 회원가입이 진행되도록 구현했습니다.

즉, UsernamePasswordAuthenticationFilter만 사용하여 서비스 자체 로그인과 Oauth2.0 방법을 이용한 로그인을 통합하여 개발했습니다.


<br>
  ### 2. 청첩장을 받은 사용자만 해당 청첩장에 접근하도록 설계
  
<br>
<b>[uuid를 통해 초대받은 청첩장만 접속하도록 구현]</b>
예비 신랑, 신부가 카카오톡이나 문자를 통해 청첩장을 전달하게 되면, 이때 처음에는 전달하는 청첩장의 도메인에 boards_id 값을 path parameter로 넣는것을 고민했습니다.

하지만 이럴 경우 사용자가 임의로 path parameter를 수정하여 접근하게 된다면 초대받지 않은 청첩장에도 접근할 수 있는 문제가 발생할 것으로 생각했습니다.

따라서 boards_id 보다는 랜덤 값인 uuid를 사용하고 정말 혹시 몰라서 uuid를 2개 사용하여 다른 청첩장에는 거의 접근하지 못하도록 만들었습니다.

<br>
<b>[http header에 특정 토큰 값을 추가하여 초대받은 사용자가 guests 테이블에 저장되어 있는지 확인]</b>
청첩장에서 사용자에게 요청이 오는 경우 매번 해당 사용자가 게스트 테이블에 저장되었는지 확인하기 보다는 저장되었다는 정보를 토큰값으로 전달하기로 했습니다.

따라서 청첩장에서 최초 요청이 있는 경우만 테이블에서 확인하고 이후에는 테이블에서 확인하지 않도록 구현할 수 있었습니다.

추가로 어떤 boards의 청첩장인지도 확인할 수 있도록 boards_id 값도 토큰에 추가했기 때문에 마찬가지로 DB 확인 없이 이후 로직을 처리할 수 있었습니다.


# 향후 계획
우선 현재 1차 배포를 마무리 한 상태이기 때문에 프론트 분들이 작업을 완료하기 까지 리팩토링을 진행할 예정입니다.

1. 가장 먼저 일부 DTO를 생성자를 통해 만드는 경우도 있고 static 메서드를 통해 만드는 경우가 있는데, 가능하면 static 메서드로 통일 시킬 예정입니다.
2. 테스트 코드를 수정할 예정입니다. 신경써서 작성한 테스트 코드가 아닌 경우 오히려 유지 보수가 어렵다고 느꼈기 때문에 테스트 코드도 리팩토링 예정입니다.

<br>

추가로 현재 controller 부분에 모두 어떤 컨트롤러인지를 알려주는 log가 존재하는데 해당 로직은 aop를 통해 수정할 예정이며 

마지막으로 특정 api에는 캐시를 적용하려 합니다.






















